/*!
\page halib Unsere Hardware-Abstraktionsbibliothek (halib)


\section halibleitlinien Leitlinien

Folgende Gesichtspunkte waren für uns beim Entwurf der Bibliothek maßgeblich:
- Flexibilität und Wiederverwendbarkeit: Die Bibliothek soll einfach zu verwenden sein
  und dabei den Anforderungen für ein möglichst breites Spektrum an Einsatzszenarien gerecht werden.
- Erweiterbarkeit und Portierbarkeit der Bibliothek für andere Plattformen: Die
  Bibliothek soll leicht um weitere, noch nicht implementierte Hardware-Komponenten
  ergänzt werden können. Außerdem haben wir versucht, die Bibliothek von anfang an so
  zu strukturieren, dass sie leicht auf andere Microcontroller-Systeme portiert werden
  kann. Zum Thema siehe auch \ref haliberweiterung.

Wir haben uns für konsequente Objektorientierung entschieden, wobei wir
versucht haben, den Overhead möglich gering zu halten. So nutzen wir im Intersse
der Flexibilität und Erweiterbarkeit beispielsweise virtueller Funktionen, so wenig
wie möglich, aber gleichzeitig so viel wie unserer Meinung nach nötig.


\section halibverwendung Verwendung der Bibliothek

Die Bibliothek lässt sich ziemlich einfach verwenden:
-# Einbinden der Header für die benötigten Komponenten aus dem Verzeichnis <tt>halib/</tt>
-# Bei Bedarf <tt>halib/config.h</tt> anpassen, um einzelne nicht benötigte Komponenten nicht mit einzucompilieren
-# Beim Compilieren gegen die Quelldateien (<tt>*.cpp</tt>) der benötigten  Komponenten aus <tt>halib/</tt> linken


\section halibbestandteile Die Bibliothek im Detail

Im folgenden Abschnitt werden die einzelnen Komponenten der Bibliothek etwas genauer beschrieben.


\subsection halibinterrupt Die Interrupt-Behandlung

In unserer Hardwarebibliothek wird jeder Interrupt-Typ durch eine abstrakte Klasse
repräsentiert. Diese definiert eine abstrakte Methode, die bei Auslösung des Interrupts
als Interrupt-Service-Routine aufgerufen wird. Auf diesem Wege lassen sich Interrupts
bequem auf Objekt-Ebene behandeln. Bei der Interrupt-Behandlung kann also direkt auf
Methoden oder Objekt-Variablen zurückgegriffen werden. \n
Um nun einen konkreten Interrupt zu behandeln, muss zuerst die entsprechende abstrakte
Klasse deklariert und implementiert werden, dies geschieht bequem über die Makros
#DECLARE_INTERRUPT_CLASS(classname) und #IMPLEMENT_INTERRUPT_CLASS(sig,classname).
Im folgenden muss dann die Klasse, deren Objekt ein Interrupt behandeln soll
von der Interrupt-Klasse erben und die ISR definieren. Die ISR ist wie die
Interrupt-Klasse, jedoch um ein vorangestelltes <tt>on</tt> ergänzt, benannt. \n

Zur Verwenung hier ein Beispiel: \n

\code
// beispiel.h:

#include "interrupt.h"

DECLARE_INTERRUPT_CLASS(Interrupt1)			

class Beispiel : public Interrupt1
{
public:
	void onInterrupt1();
};
\endcode

\code
// beispiel.cpp:

#include "beispiel.h"

IMPLEMENT_INTERRUPT_CLASS(SIG_INTERRUPT1, Interrupt1)	// External Interrupt Request 1

void Beispiel::onInterrupt1()
{
	// Hier Interrupt behandeln...
}
\endcode

Die Interrupt-Behandlung werden beispielsweise auch in den Klassen zur Abstraktion der
Hardware-Timer des ATmega32 eingesetzt.

\subsection halibtimer Die Timer

<table><tr><td>
Anmerkung zur Versionsgeschichte: \n
Anfangs wollten wir sehr flexible Timerklassen entwickeln, die Zeitangaben in
gebräuchlichen Zeiteinheiten wie Millisekunden unterstützen sollten. Außerdem
sollten mehre "Klienten" pro Hardware-Timer bediehnt werden können. Letztes
war auch schon im wesentlichen implementiert, jedoch haben sich die
entstandenen Timer-Klassen alles andere als intuitiv handhaben lassen,
so dass wir uns im Timerbereich radikal vom Überfeaturungsgedanken abgewendet
haben. Die neu geschriebenen Klassen sind dem entsprechend sehr einfach
ausgefallen und im wesentlichen an den Anforderungen der Anwendungsaufgabe
orientiert.
</td></tr></table>

Bei unserer Timer-Abstraktion handelt es sich nicht um eine vollständige
Implementierung aller vom ATmega32 unterstützen Timer-Modi. Die Bibliothek
stellt im Moment nur für jeden der drei Timer eine Timer-Klasse bereit,
die die jeweils verfügbaren Prescaling-Modi unterstützt und in der
eingestellten Prescaler-Frequenz die Timer-Behandlungsroutine
aufruft. Da alle Timer über eine Timer-Behandlungsroutine verfügen gibt es
für Timer eine gemeinsame abstrakte Basisklasse, die diese Routine
(<tt>void onTimer()</tt>) abstrakt definiert.
Um einen Timer zu verwenden leitet man ähnlich wie bei der Interrupt-Behandlung
die Klasse, deren Objekt den Timer verwenden soll, von der entsprechenden Timer-
Klasse ab und definiert dann eine Handler-Methode <tt>void onTimer()</tt>.


Zur Verwenung hier ein Beispiel:

\code
// beispiel2.h:

#include "timer.h"

class Beispiel2 : public Timer1
{
public:
	void onTimer();
};
\endcode

\code
// beispiel2.cpp:

#include "beispiel2.h"

void Beispiel2::onTimer()
{
	// Hier Timer-Event behandeln...
}

int main()
{
	Beispiel2 b;
	b.start(TIMER_PS_1024);
	// ...
	b.stop();
}
\endcode

Die Bibliothek lässt sich leich für andere durch die Hardware unsterstützte
Timer-Modi erweitern, indem man neue Timer-Klassen von der Timer-Basisklasse ableitet
und Implementiert.


\subsection halibdigitalout Digitale Ein- und Ausgänge

Das BobbyBoard verfügt über mehrere digitale Ein- und Ausgänge, die über die Ports
des ATmega32 angesprochen werden können. Die LEDs und Buttons des BobbyBoards
lassen sich über die Ports des ATmega32 setzen bzw. abfragen. Um diesen
Gemeinsamkeiten gerecht zu werden haben wir die Klassen DigitalIn und
DigitalOut entwickelt, die das Konzept eines digitalen Ein- bzw. Ausgangs
abbilden. Beide Klassen haben als wesentliche Eigenschaft eine Referenz auf
den Port, auf dem sie operieren und eine Bitmaske, die die Bits des Ports kennzeichnet,
auf dem die Ein- bzw. Ausgänge liegen. Die Konstrukoren nehmen als weitere Argumente
Referenzen auf andere Register des ATmega32, über die sich die einzelnen Pins der
Ports als Ein- bzw. Ausgänge konfigurieren lassen.

Als speziellen digitalen Ausgang haben wir die Klasse Led von DigitalOut abgeleitet.
Sie erweitert den digitalen Ausgang jedoch um ein paar besser benannte Methoden, die
Methoden der Basisklasse aufrufen.

Analog dazu haben wir Button als speziellen digitalen Eingang definiert.

Bei der Arbeit mit dem Roboter hat sich jedoch gezeigt, dass es oft praktisch ist
alle LEDs mit einem Mal auf ein Muster zu setzen. Aus diesem Grund haben wir die Bibliothek um die
Klasse LedBlock erweitert, über die sich mehrere LEDs an einem Port mit einem
Methodenaufruf setzen lassen.

Analog dazu lassen sich über ButtonBlock mehrere Buttons an einem Port mit einem
Methodenaufruf abfragen.


\subsection halibsensoren Die Sensoren

Alle Sensoren (sowohl digitale als auch analoge) können zum Beispiel zur
Listenverarbeitung über ein gemeinsames Inferface Sensor
angesprochen werden. Die Sensoren werden in zwei verschiedene Klassen
eingeordnet DigitalSensor und AnalogSensor. Da die
Analog-Digital-Wandlung viel Zeit in Anspruch nimmt kann die Abfrage der
Sensoren, altenativ zur Abfrage mit starten und warten (<tt>register_t getValue()</tt>),
auch in Auftrag (<tt>virtual bool startGetValue()</tt>) und Ergebnissabfrage
(<tt>register_t getCachedValue()</tt>) unterteilt werden, um die Arbeitszeit
des AD-Wandlers für andere Berechnungen zu nutzen.


\code
// beispielsensor1.cpp:

#include "sensor.h"
..
Sensor * sensor = & AnalogSensor(0);

void foo()
{
	// starten 
	if(sensor->startGetValue())
	{
		// Zeit kann beliebig genutzt werden
	
		// Sicherstellen, dass der Wert verfügbar ist
		while(sensor->isReady());
	
		// Wert lesen
		register_t a = sensor->getCachedValue();
		
		// ...
	}
	else
	{
		// Hier Auftrags NichtAnnahme behandeln Grund z.B.
		// Analog-Digital-Wandler belegt
	
	}
}

\endcode

\code
// beispielsensor2.cpp:

#include "sensor.h"

Sensor * sensor = & AnalogSensor(0);

void foo2()
{
	// Wert lesen
	register_t a = sensor->getValue();

	// ...
}
\endcode

\subsection halibmotoren Die Motoren

Unsere selbst geschriebene Abstraktion für Motoren (Motor) unterstützt die Verwendung
beliebiger Ports und Pin-Konfigurationen zur Ansteuerung der Motoren, ähnlich
wie DigitalOut. Zum Betreiben der Motoren in einer definierten Geschwindigkeit,
die kleiner als die Maximalgeschwindigkeit ist, wurde eine Software-Plusweiten-
Modulation programmiert, die keine Begrenzung (abgesehen von den Resourcen)
für die Anzahl der betriebenen Motoren besitzt, da die Motoren in einer
verketteten Liste organisiert werden. Für die PWM wird Timer2 reserviert,
dieser kann also bei Verwenung eines Motors nicht anderweitig genutzt werden.

Außerdem verfügt der Motor über eine Kalibrierungsfunktion, die aber aus Zeitmangel
nicht ausreichend getestet werden konnte und daher in der Aufgabenlösung nicht
verwendet wurde.



\subsection halibcdevices "Char-Devices"

Da viele Ein- und Ausgabeschnittstellen Zeichen-basiert funktionieren, stellen
wir für all diese Geräte ein Interface <tt>CDevice</tt> zur Verfügung, so dass
diese einheitlich angesprochen werden können. Das Interface ergänzt Geräte, die
nur einzelne Zeichen ausgeben könne um die Möglichkeit zur Ausgabe von
C-Zeichenketten und Zahlen. Die bisher einzige ausgereifte und von uns eingesetzte
Implementierung dieses Interfaces stellt Uart dar.


\subsection halibrest Andere nützliche Klassen

Im Rahmen der Implementierung diverser Char-Devices entstand auch die Template-Klasse
QueueBuffer als Bestandteil der Hardware-Bibliothek. Diese hat zwar nicht direkt
was mit Hardware-Abstraktion zu tun, könnte sich aber trotzdem für so manche
Anwendung als brauchbar erweisen. Zur Lösung der Aufgabe fand sie auch Verwendung
in Terminal und ReverseDijkstraMap.

*/

/*!
\page haliberweiterung Erweiterung unserer Hardware-Abstraktionsbibliothek


\section haliberweiterungkomponenten Erweiterung der Bibliothek um weitere Komponenten

Die Bibliothek kann leicht um weitere Hardwarekomponenten erweitert werden, indem
entsprechende Dateien in die Verzeichnisstruktur eingebaut werden. Dabei ist jedoch
nach Möglichkeit darauf zu achten, die verwendeten Namenskonventionen zu beachten:
im Wesentlichen Großschreibung von Klassennamen und Kleinschreibung von
Funktionsnamen und Variablen. Dabei werden bei zusammengesetzten Worten neue Worte
immer groß begonnen (<tt>eineVariable</tt>, <tt>EineKlasse</tt>). Außerdem sollte
die räumliche Aufteilung von gemeinsamem und plattformspezifischem Code beibehalten
werden und es sollten die in <tt>halib/config.h</tt> definierten Datentypen verwendet
werden, um die \ref haliberweiterungplattformen zu erleichtern.


\section haliberweiterungplattformen Erweiterung der Bibliothek für andere Plattformen

Der Quellcode unserer Hardware-Abstraktions-Bibliothek ist so organisiert, dass sich
die Bibliothek recht einfach für die Unterstützung anderer Plattformen erweitern
lässt. Plattformspezifischer Code befindet sich in jeweils einem eigenen Unterverzeichnis
von <tt>halib/</tt>. So z.B. der Code für den ATmega32 in <tt>halib/atmega32/</tt>.
Um die Bibliothek zu erweitern, muss zuerst ein solches Unterverzeichnis angelegt werden.
In diesem sollten dann die zu unterstützenden Features implementiert werden (Beispiel
siehe <tt>halib/atmega32/*.*</tt>). Um die Portierung für den entsprechenden
Microcontroller bequem per Compiler-Zielgerät-Parameter verwenden zu können,
müssen jetzt zum einem gewisse Hardware-Paramter für die Plattform definiert werden.
Dies geschieht in der Datei <tt>halib/config.h</tt>, die hier um eine fiktive Plattform
ABc1234 von XYZ erweitert wurde, die über 16-Bit-Register verfügt.

\code
// file: halib/config.h:

// ...

#if defined (__AVR_ATmega32__)		// bereits vorhanden
typedef uint8_t port_t;
typedef uint8_t register_t;
#elif defined (__XYZ_ABc1234__)		// ergänzt die neue Plattform
typedef uint8_t port_t;
typedef uint16_t register_t;
#else
# error "device type not defined or not supportet"
#endif

// ...
\endcode

Außerdem muss in den allgemeinen Dateien für die unterstützten Komponenten der
Verweis zu der jeweiligen Plattform-Implementierung eingefügt werden. In diesem
Beispiel wird die Timer-Implementierung für die fiktive Plattform ABc1234 eingebunden.

\code
// halib/timer.cpp

// ...

#if defined (__AVR_ATmega32__)		// bereits vorhanden
# include "atmega32/timer.cpp"
#elif defined (__XYZ_ABc1234__)		// ergänzt die neue Plattform
# include "abc1234/timer.cpp"
#else
# error "device type not defined or not supportet"
#endif
\endcode

\code
// halib/timer.h

// ...

#if defined (__AVR_ATmega32__)		// bereits vorhanden
# include "atmega32/timer.h"
#elif defined (__XYZ_ABc1234__)		// ergänzt die neue Plattform
# include "abc1234/timer.h"
#else
# error "device type not defined or not supportet"
#endif
\endcode

*/
 
