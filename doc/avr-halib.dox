/*
	- benefits
	- usage
	- development guidelines

directories erklären
ext
- external devices, extensions; peripherals
portmaps: common frequently used portmaps

Portmaps
Delegates

skaliert gut

Portmap:
- zentraler punkt, wo schnittstelle avr zu peripherie geschaffen wird
- protmap-definitionen können in C++ eingebettet werden, wenn "portmap nicht als bezeichner verwendet wird"


Coding-Conventions
- filenames lower case
- kleine Übersetzungseinheiten


empfolene Compilerschalter:
verwende keine "int"s
http://www.mikrocontroller.net/articles/AVR-GCC-Codeoptimierung
http://www.atmel.com/dyn/resources/prod_documents/doc1497.pdf

kein volatile bei portmaps... statdessen sync... erklären
*/

/*!
\mainpage

\author Michael Schulze, Philipp Werner and Karl Fessel

<b>This Documantation is preliminary.</b>

Avr-halib is a library for easy writing of efficient, portable, reusable and
readable programs for AVR microcontrollers in C++.

Its main attributes are: \li reusability, portability: when changing your
hardware you just have to change only a few configurations. No changes in your
code are necessary concerning access to internal and external hardware.  \li
readability: Once you know the concepts your code should be very readable.  \li
efficiency: No extra RAM is needed! In addition optimal code generated by use
of templates and bitfields, vports and enums.

This library was written by Philipp Werner
(<tt>philipp.werner(at)st.ovgu.de</tt>), Karl Fessel
(<tt>karl.fessel(at)st.ovgu.de</tt>) and Michael Schulze
(<tt>mschulze(at)ovgu.de</tt>) at the working group for Embedded and Operating
Systems (EOS) at the University of Magdeburg, Germany.

The main concepts are developed by Michael Schulze. Subconcepts, refinemens and
most implementation work are done by Philipp Werner and Karl Fessel.


To get to know avr-halib see \ref doc_faq and \ref doc_start.

Concepts:
\li \ref doc_portmaps
\li \ref doc_interrupts

AVR Classes:
 \li \ref at90can128::ADConv
 \li \ref at90can128::Timer0
 \li \ref at90can128::Timer1
 \li \ref at90can128::Timer2
 \li \ref at90can128::Timer3
 \li ... and other, however not documented yet

External hardware abstraction classes:
\li \ref Led
\li \ref avr_halib::drivers::external::RobbyMotorControl

Additional:
\li \ref delay.h

\ref doc_dev
*/

/*
\page doc_cdevices Charcter devices

Da viele Ein- und Ausgabeschnittstellen Zeichen-basiert funktionieren, stellen
wir f�r all diese Ger�te ein Interface <tt>CDevice</tt> zur Verf�gung, so dass
diese einheitlich angesprochen werden k�nnen. Das Interface erg�nzt Ger�te, die
nur einzelne Zeichen ausgeben k�nne um die M�glichkeit zur Ausgabe von
C-Zeichenketten und Zahlen. Die bisher einzige ausgereifte und von uns eingesetzte
Implementierung dieses Interfaces stellt Uart dar.

\page doc_delegates Delegates

\page doc_interrupt Interrupts

In unserer Hardwarebibliothek wird jeder Interrupt-Typ durch eine abstrakte Klasse
repr�sentiert. Diese definiert eine abstrakte Methode, die bei Ausl�sung des Interrupts
als Interrupt-Service-Routine aufgerufen wird. Auf diesem Wege lassen sich Interrupts
bequem auf Objekt-Ebene behandeln. Bei der Interrupt-Behandlung kann also direkt auf
Methoden oder Objekt-Variablen zur�ckgegriffen werden. \n
Um nun einen konkreten Interrupt zu behandeln, muss zuerst die entsprechende abstrakte
Klasse deklariert und implementiert werden, dies geschieht bequem �ber die Makros
#DECLARE_INTERRUPT_CLASS(classname) und #IMPLEMENT_INTERRUPT_CLASS(sig,classname).
Im folgenden muss dann die Klasse, deren Objekt ein Interrupt behandeln soll
von der Interrupt-Klasse erben und die ISR definieren. Die ISR ist wie die
Interrupt-Klasse, jedoch um ein vorangestelltes <tt>on</tt> erg�nzt, benannt. \n

Zur Verwenung hier ein Beispiel: \n

\code
// beispiel.h:

#include "interrupt.h"

DECLARE_INTERRUPT_CLASS(Interrupt1)

class Beispiel : public Interrupt1
{
public:
	void onInterrupt1();
};
\endcode

\code
// beispiel.cpp:

#include "beispiel.h"

IMPLEMENT_INTERRUPT_CLASS(SIG_INTERRUPT1, Interrupt1)	// External Interrupt Request 1

void Beispiel::onInterrupt1()
{
	// Hier Interrupt behandeln...
}
\endcode

Die Interrupt-Behandlung werden beispielsweise auch in den Klassen zur Abstraktion der
Hardware-Timer des ATmega32 eingesetzt.


\page doc_timer Timer

<table><tr><td>
Anmerkung zur Versionsgeschichte: \n
Anfangs wollten wir sehr flexible Timerklassen entwickeln, die Zeitangaben in
gebr�uchlichen Zeiteinheiten wie Millisekunden unterst�tzen sollten. Au�erdem
sollten mehre "Klienten" pro Hardware-Timer bediehnt werden k�nnen. Letztes
war auch schon im wesentlichen implementiert, jedoch haben sich die
entstandenen Timer-Klassen alles andere als intuitiv handhaben lassen,
so dass wir uns im Timerbereich radikal vom �berfeaturungsgedanken abgewendet
haben. Die neu geschriebenen Klassen sind dem entsprechend sehr einfach
ausgefallen und im wesentlichen an den Anforderungen der Anwendungsaufgabe
orientiert.
</td></tr></table>

Bei unserer Timer-Abstraktion handelt es sich nicht um eine vollst�ndige
Implementierung aller vom ATmega32 unterst�tzen Timer-Modi. Die Bibliothek
stellt im Moment nur f�r jeden der drei Timer eine Timer-Klasse bereit,
die die jeweils verf�gbaren Prescaling-Modi unterst�tzt und in der
eingestellten Prescaler-Frequenz die Timer-Behandlungsroutine
aufruft. Da alle Timer �ber eine Timer-Behandlungsroutine verf�gen gibt es
f�r Timer eine gemeinsame abstrakte Basisklasse, die diese Routine
(<tt>void onTimer()</tt>) abstrakt definiert.
Um einen Timer zu verwenden leitet man �hnlich wie bei der Interrupt-Behandlung
die Klasse, deren Objekt den Timer verwenden soll, von der entsprechenden Timer-
Klasse ab und definiert dann eine Handler-Methode <tt>void onTimer()</tt>.


Zur Verwenung hier ein Beispiel:

\code
// beispiel2.h:

#include "timer.h"

class Beispiel2 : public Timer1
{
public:
	void onTimer();
};
\endcode

\code
// beispiel2.cpp:

#include "beispiel2.h"

void Beispiel2::onTimer()
{
	// Hier Timer-Event behandeln...
}

int main()
{
	Beispiel2 b;
	b.start(TIMER_PS_1024);
	// ...
	b.stop();
}
\endcode

Die Bibliothek l�sst sich leich f�r andere durch die Hardware unsterst�tzte
Timer-Modi erweitern, indem man neue Timer-Klassen von der Timer-Basisklasse ableitet
und Implementiert.


\subsection avr-halibdigitalout Digitale Ein- und Ausg�nge

Das BobbyBoard verf�gt �ber mehrere digitale Ein- und Ausg�nge, die �ber die Ports
des ATmega32 angesprochen werden k�nnen. Die LEDs und Buttons des BobbyBoards
lassen sich �ber die Ports des ATmega32 setzen bzw. abfragen. Um diesen
Gemeinsamkeiten gerecht zu werden haben wir die Klassen DigitalIn und
DigitalOut entwickelt, die das Konzept eines digitalen Ein- bzw. Ausgangs
abbilden. Beide Klassen haben als wesentliche Eigenschaft eine Referenz auf
den Port, auf dem sie operieren und eine Bitmaske, die die Bits des Ports kennzeichnet,
auf dem die Ein- bzw. Ausg�nge liegen. Die Konstrukoren nehmen als weitere Argumente
Referenzen auf andere Register des ATmega32, �ber die sich die einzelnen Pins der
Ports als Ein- bzw. Ausg�nge konfigurieren lassen.

Als speziellen digitalen Ausgang haben wir die Klasse Led von DigitalOut abgeleitet.
Sie erweitert den digitalen Ausgang jedoch um ein paar besser benannte Methoden, die
Methoden der Basisklasse aufrufen.

Analog dazu haben wir Button als speziellen digitalen Eingang definiert.

Bei der Arbeit mit dem Roboter hat sich jedoch gezeigt, dass es oft praktisch ist
alle LEDs mit einem Mal auf ein Muster zu setzen. Aus diesem Grund haben wir die Bibliothek um die
Klasse LedBlock erweitert, �ber die sich mehrere LEDs an einem Port mit einem
Methodenaufruf setzen lassen.

Analog dazu lassen sich �ber ButtonBlock mehrere Buttons an einem Port mit einem
Methodenaufruf abfragen.


\subsection avr-halibsensoren Die Sensoren

Alle Sensoren (sowohl digitale als auch analoge) k�nnen zum Beispiel zur
Listenverarbeitung �ber ein gemeinsames Inferface Sensor
angesprochen werden. Die Sensoren werden in zwei verschiedene Klassen
eingeordnet DigitalSensor und AnalogSensor. Da die
Analog-Digital-Wandlung viel Zeit in Anspruch nimmt kann die Abfrage der
Sensoren, altenativ zur Abfrage mit starten und warten (<tt>register_t getValue()</tt>),
auch in Auftrag (<tt>virtual bool startGetValue()</tt>) und Ergebnissabfrage
(<tt>register_t getCachedValue()</tt>) unterteilt werden, um die Arbeitszeit
des AD-Wandlers f�r andere Berechnungen zu nutzen.


\code
// beispielsensor1.cpp:

#include "sensor.h"
..
Sensor * sensor = & AnalogSensor(0);

void foo()
{
	// starten
	if(sensor->startGetValue())
	{
		// Zeit kann beliebig genutzt werden
	
		// Sicherstellen, dass der Wert verf�gbar ist
		while(sensor->isReady());
	
		// Wert lesen
		register_t a = sensor->getCachedValue();
		
		// ...
	}
	else
	{
		// Hier Auftrags NichtAnnahme behandeln Grund z.B.
		// Analog-Digital-Wandler belegt
	
	}
}

\endcode

\code
// beispielsensor2.cpp:

#include "sensor.h"

Sensor * sensor = & AnalogSensor(0);

void foo2()
{
	// Wert lesen
	register_t a = sensor->getValue();

	// ...
}
\endcode

\subsection avr-halibmotoren Die Motoren

Unsere selbst geschriebene Abstraktion f�r Motoren (Motor) unterst�tzt die Verwendung
beliebiger Ports und Pin-Konfigurationen zur Ansteuerung der Motoren, �hnlich
wie DigitalOut. Zum Betreiben der Motoren in einer definierten Geschwindigkeit,
die kleiner als die Maximalgeschwindigkeit ist, wurde eine Software-Plusweiten-
Modulation programmiert, die keine Begrenzung (abgesehen von den Resourcen)
f�r die Anzahl der betriebenen Motoren besitzt, da die Motoren in einer
verketteten Liste organisiert werden. F�r die PWM wird Timer2 reserviert,
dieser kann also bei Verwenung eines Motors nicht anderweitig genutzt werden.

Au�erdem verf�gt der Motor �ber eine Kalibrierungsfunktion, die aber aus Zeitmangel
nicht ausreichend getestet werden konnte und daher in der Aufgabenl�sung nicht
verwendet wurde.






\subsection avr-halibrest Andere n�tzliche Klassen

Im Rahmen der Implementierung diverser Char-Devices entstand auch die Template-Klasse
QueueBuffer als Bestandteil der Hardware-Bibliothek. Diese hat zwar nicht direkt
was mit Hardware-Abstraktion zu tun, k�nnte sich aber trotzdem f�r so manche
Anwendung als brauchbar erweisen. Zur L�sung der Aufgabe fand sie auch Verwendung
in Terminal und ReverseDijkstraMap.

*/
